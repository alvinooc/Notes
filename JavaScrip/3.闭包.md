1. #### 定义

- 在计算机科学中对闭包的定义（维基百科）：
  - 闭包（Closure），又称**词法闭包**（Lexical Closure）或 **函数闭包**（function closures）
  - 是在支持 **头等函数** 的编程语言中，实现词法绑定的一种技术
  - 闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）
  - 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 **自由变量** 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行
- MDN对闭包的解释：
  - 一个函数和对其周围状态（**Lexical environment，词法环境）引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包**
  - 也就是说，闭包可以在一个内层函数中访问到其外层函数的作用域
  - 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来
- 总结：
  - 一个普通的函数，如果它可以访问外层作用域的自由变量，那么这个函数就是一个闭包
  - 从广义的角度来说：JavaScript 中的函数都是闭包
  - 从狭义的角度来说：JavaScript 中的一个函数，如果访问了外层作用域变量，那么它是一个闭包

#### 2.闭包的访问过程

![image-20220415200855005](https://cdn.jsdelivr.net/gh/alvinooc/Notes@master/Images/image-20220415200855005.png)

#### 3.闭包的执行过程

- makeAdder函数执行完毕后，正常情况下AO对象会被释放
- 但是因为在0xb00的函数中有作用域引用指向了这个AO对象，所以它不会被释放掉![image-20220415200927087](https://cdn.jsdelivr.net/gh/alvinooc/Notes@master/Images/image-20220415200927087.png)

#### 4.闭包的内存泄漏

- 原因：
  - 在上面的例子中，如果后续不再使用add10函数了，那么该函数对象应该要被销毁掉，且其引用的父作用域AO也应该被销毁掉
  - 但是因为在全局作用域下add10变量对0xb00的函数对象有引用，而0xb00的作用域中对AO（0x200）有引用，所以最终会造成这些内存无法被释放。即闭包造成的内存泄漏
- 解决方法：add10 = null
  - 因为当将add10设置为null时，就不再对函数对象0xb00有引用，那么对应的AO对象0x200也就不可达了
  - 在GC的下一次检测中，它们就会被销毁掉

#### 5.AO对象不会被销毁时，里面不使用的属性会被释放

![image-20220415201029379](https://cdn.jsdelivr.net/gh/alvinooc/Notes@master/Images/image-20220415201029379.png)
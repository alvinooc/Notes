- JS引擎会在执行代码之前在堆内存中创建一个全局对象：Global Object（GO）

  - 该对象所有的作用域（scope）都可以访问
  - 包含Data、Array、String、Number、setTimeout、setInterval等等
  - 其中还有一个window属性指向自

- JS引擎内部有一个**执行上下文栈（Execution Context Stack，简称ECS），用于执行全局的代码块**

- 全局的代码块为了执行会构建一个 **Global Execution Context（GEC）**

- GEC 会被放入到ECS中执行，其中包含两部分内容：

  - **第一部分**：在代码执行前，即parser转成AST的过程中，会将全局定义的变量、函数等加入到Global Object中，但是并不会赋值。该过程也称之为变量的作用域提升(hoisting)

  - **第二部分**：在代码执行中，对变量赋值或执行其他的函数

    ![image-20220414210505967](https://cdn.jsdelivr.net/gh/alvinooc/Notes@master/Image/image-20220414210505967.png)

    ![image-20220414210653561](https://cdn.jsdelivr.net/gh/alvinooc/Notes@master/Image/image-20220414210653561.png)

- 在执行到一个函数时，会根据函数体创建一个**函数的执行上下文（Functional Execution Context，简称FEC），**并且压入到EC Stack中。FEC中包含三部分内容：

  - 第一部分：在解析函数成为AST树结构时，会创建一个Activation Object（AO）

    - AO中包含形参、arguments、函数定义和指向函数对象、定义的变量

  - 第二部分：作用域链，由VO（在函数中就是AO对象）和父级VO组成，查找时会一层层查找

  - 第三部分：this绑定的值

    ![image-20220414210948671](https://cdn.jsdelivr.net/gh/alvinooc/Notes@master/Image/image-20220414210948671.png)

    

- JavaScript会在定义变量时分配内存

  - 对于**基本数据类型的内存分配**会在执行时，直接在栈空间进行分配

  - 对于**复杂数据类型的内存分配**会在堆内存中开辟一块空间，并且将这块空间的指针返回给值变量引用

    

- JS的垃圾回收

  - 因为**内存的大小是有限**的，所以当**内存不再需要的时候**，需要**对其进行释放**，以腾出**更多的内存空间**

  - 在手动管理内存的语言中，需要通过一些方式来释放不再需要的内存，比如free函数：
    - 但是这种管理的方式非常的低效，影响编写逻辑代码的效率
    - 并且这种方式对开发者的要求也很高，很容易产生内存泄漏

  - 所以大部分现代的编程语言都有自己的垃圾回收机制
    - 垃圾回收的英文是Garbage Collection，简称GC
    - JavaScript的运行环境JS引擎自带垃圾回收器，也简称为GC
    - 通过GC算法来判断哪些对象不再使用

  - 常见的GC算法
    - **引用计数**
      - 当一个对象有一个引用指向它时，那么这个对象的引用就+1；当一个对象的引用为0时，这个对象就可以被销毁掉
      - 这个算法有一个很大的弊端就是会产生循环引用
    - **标记清除（常用）**
      - 这个算法时设置一个跟对象（root object），垃圾回收器会定期从这个根开始，查找其有引用到的对象，对于那些未引用到的对象，就认为是不可用的对象
      - 这个算法可以很好的解决循环引用的问题

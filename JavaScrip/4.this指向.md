#### 1.全局作用域下（浏览器环境）

* this指向window，但this通常都是在**函数中使用**
* 所有的函数在被调用时，都会创建一个执行上下文
* 这个上下文中记录着函数的调用栈、AO对象等
* this也是其中的一条记录

#### 2.绑定规则

- **规则一：默认绑定**

  - 独立函数调用，即函数没有被绑定到某个对象上进行调用

    ![image-20220415201852322](https://cdn.jsdelivr.net/gh/alvinooc/Notes@master/Images/image-20220415201852322.png)

- **规则二：隐式绑定**

  - 通过某个对象进行调用

    ![image-20220415201907627](https://cdn.jsdelivr.net/gh/alvinooc/Notes@master/Images/image-20220415201907627.png)

  - 隐式绑定有一个前提条件：

    - 必须在调用的内部有一个对函数的引用（比如一个属性）
    - 如果没有这样的引用，在进行调用时，会报找不到该函数的错误
    - 正是通过这个引用，间接的将this绑定到了这个对象上

- **规则三：显示绑定**

  - **通过call或者apply绑定this对象**

    - 显示绑定后，this就会明确的指向绑定的对象
    - 两者的区别：第一个参数是相同的，后面的参数，apply为数组，call为参数列表

    ![image-20220415201924661](https://cdn.jsdelivr.net/gh/alvinooc/Notes@master/Images/image-20220415201924661.png)

  - **通过bind可以将一个函数总是显示的绑定到一个对象上（优先级高于默认绑定）**

    ![image-20220415201937899](https://cdn.jsdelivr.net/gh/alvinooc/Notes@master/Images/image-20220415201937899.png)

- **规则四：new绑定**

  - JavaScript中的函数可以当作一个类的构造函数来使用，也就是使用new关键字

  - 使用new关键字来调用函数时，会执行以下操作：

    1. 创建一个全新的对象
    2. 这个新对象会被执行prototype连接
    3. 这个新对象会绑定到函数调用的this上（this的绑定在这个步骤完成）
    4. 如果函数没有返回其他对象，表达式会返回这个新对象

    ![image-20220415202004553](https://cdn.jsdelivr.net/gh/alvinooc/Notes@master/Images/image-20220415202004553.png)

#### 3.**规则优先级**

1. **默认规则的优先级最低**
2. **显示绑定优先级高于隐式绑定**
3. **new 绑定优先级高于隐式绑定**
4. new 绑定优先级高于 bind
   - new 绑定和 call、apply 是不允许同时使用的，所以不存在谁的优先级更高
   - new 绑定可以和 bind 一起使用，new 绑定优先级更高

#### 4.**this 规则之外**

- **忽略显示绑定**

  - 如果在显示绑定中，传入一个 **null** 活着 **undefined**，那么这个显示绑定会被忽略，使用默认规则

    ![image-20220415202036129](https://cdn.jsdelivr.net/gh/alvinooc/Notes@master/Images/image-20220415202036129.png)

- **间接函数引用**

  - 创建一个函数的间接使用，这种情况也使用默认绑定规则

    - 赋值 (obj2.foo = obj1.foo) 的结果是 foo 函数
    - foo 函数被直接调用，那么是默认绑定

    ![image-20220415202151413](https://cdn.jsdelivr.net/gh/alvinooc/Notes@master/Images/image-20220415202151413.png)

​		
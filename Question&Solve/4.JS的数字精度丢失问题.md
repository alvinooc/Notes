1. 表现：

   - **两个简单的浮点数相加**

     > 0.1 + 0.2 ≠ 0.3 // true

   - **大整数运算**

     > 9999999999999999 == 10000000000000001  // true

     > 9007199254740992 + 1 == 9007199254740992 // true

   - **toFixed 不会四舍五入**（Chrome）

     > 1.335.toFixed(2)  // 1.33

   - **JSON 解析大整数会丢失精度**

     ```js
     var data = '{"success":"true","projectId":730107215209299968}';
     var obj = JSON.parse(data); 
     console.log(obj.projectId); // 730107215209300000
     
     // 解决方式：正则表达式
     // 1.json 中只有一个数字项
     var pattern = /[1-9][0-9]*/;
     console.log(data.match(pattern)); // 730107215209299968
     // 2.匹配 projectId：730107215209299968 何种 key value 形式的
     var newResponseString = data.replace(/\"projectId\":{\d+}/,'"projcetId": "$1"');
     var resultObj = JSON.parse(newResponseString)
     console.log(resultObj.projcetId); // 730107215209299968
     ```

2. 原因

   * 计算机的二进制实现和位数限制有些数无法有限表示。JS遵循 [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) 规范，采用双精度存储（double precision），占用 64 bit。如图：

     ![image-20220415203700824](https://cdn.jsdelivr.net/gh/alvinooc/Notes@master/Images/image-20220415203700824.png)

     - 1位用来表示符号位
     - 11位用来表示指数
     - 52位表示尾数

   * 浮点数，比如：

     > 0.1 >> 0.0001 1001 1001 1001...(1001无限循环)

     > 0.2 >> 0.0011 0011 0011 0011...(0011无限循环)

     - 此时只能模仿十进制进行四舍五入了，但是二进制只有 0 和 1 两个，于是变为 0 舍 1 入
     - 这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因

   * 大整数的精度丢失和浮点数本质上是一样的，尾数为最大是 52 位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即 9007199254740992

     - 大于 9007199254740992 的可能会丢失精度

       > 9007199254740992        >> 10000000000000...000  // 共计 53 个 0

       > 9007199254740992 + 1  >> 10000000000000...001  // 共计 52 个 0

       > 9007199254740992 + 2  >> 10000000000000...010  // 共计 52 个 0

     - 实际上

       > 9007199254740992 + 1 = 9007199254740992  // 丢失

       > 9007199254740992 + 2 = 9007199254740994  // 未丢失

       > 9007199254740992 + 3 = 9007199254740996  // 丢失

       > 9007199254740992 + 4 = 9007199254740996  // 未丢失

   * 以上，可以知道看似有穷的数字，在计算机的二进制表示里却是无穷的，由于存储位数限制，因此存在“舍去”，精度丢失就发生了

3. 解决方案

   - 把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）

     ```js
     // 0.1 + 0.2
     (0.1 * 10 + 0.2 * 10) / 10 == 0.3  // true
     ```

     
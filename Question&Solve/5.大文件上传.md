- 使用 spark-md5 获取文件 md5

- **将大文件分片上传**

  ```vue
  <template>
    <el-upload
      class="yoo-upload-file"
      :class="{ 'theme-box': theme === 'box' }"
      :drag="theme === 'box'"
      :action="isBigFile ? '' : Base_Url"
      :auto-upload="!isBigFile"
      :headers="headers"
      :data="{
        domain,
      }"
      :show-file-list="theme === 'button' && showFileList"
      :on-success="handleAvatarSuccess"
      :on-error="handleAvatarError"
      :on-change="handleAvatarChange"
      :before-upload="beforeUpload"
      :on-progress="progress"
      :on-remove="remove"
      :file-list="files"
      :limit="limit"
      :disabled="percent > 0"
    >
      <template v-if="$slots.default">
        <slot v-if="percent === 0"></slot>
        <span v-else>{{ percent }}%</span>
      </template>
      <template v-if="!$slots.default">
        <el-button v-if="theme === 'button'" :disabled="disabled" type="primary" size="small" icon="el-icon-upload">
          <template v-if="percent === 0">{{ btnName }}</template>
          <template v-else>上传中（{{ percent }}%）</template>
        </el-button>
        <template v-else>
          <template v-if="percent === 0">
            <i class="el-icon-upload" size="20"></i>
            <div class="el-upload__text">将文件拖到此处，或<em>点击上传</em></div>
          </template>
          <div v-else><i class="el-icon-loading"></i> 上传中（{{ percent }}%）</div>
        </template>
      </template>
    </el-upload>
  </template>
  <script>
  import SparkMD5 from 'spark-md5'
  import axios from 'axios'
  
  import { getToken } from 'yootrial-plugins-dt/src/lib/utils/token'
  import { getAppOrgId } from 'yootrial-plugins-dt/src/lib/utils/index'
  export default {
    props: {
      baseApi: {
        type: String,
        default: process.env.BASE_API,
      },
      fileList: {
        type: Array,
        default: () => [],
      },
      disabled: {
        type: Boolean,
        default: false,
      },
      showFileList: {
        type: Boolean,
        default: true,
      },
      types: {
        type: Array,
        default: () => [],
      },
      btnName: {
        type: String,
        default: '上传文件',
      },
      // 文件大小限制， 单位Mb
      size: {
        type: Number,
        default: 200,
      },
      // 主题 'button' 和 'box'
      theme: {
        type: String,
        default: 'button',
      },
      limit: {
        type: Number,
        default: 99,
      },
      // 大文件上传
      isBigFile: {
        type: Boolean,
        default: false,
      },
      // 分片大小，单位MB
      chunkSize: {
        type: Number,
        default: 5,
      },
      // 是否关闭了当前页
      isCancel: {
        type: Boolean,
        default: false,
      },
    },
    data() {
      return {
        Base_Url: '',
        headers: {
          Authorization: getToken(),
        },
        loading: false,
        imageUrl: '',
        fileCode: '',
        percent: 0,
        files: [],
        domain: '',
        cancel: null, // 取消axios请求的函数
        isCancelFileReader: false, // 是否取消md5加密
        fileRaw: null,
      }
    },
    watch: {
      fileList(val) {
        const arr = []
        for (let i = 0; i < this.fileList.length; i++) {
          arr.push({
            name: this.fileList[i].fileName,
            response: {
              code: 0,
              data: this.fileList[i].filePath,
            },
          })
        }
        this.files = arr
      },
      isCancel: {
        handler(val) {
          if (val) {
            this.isCancelFileReader = true
            if (this.cancel) this.cancel()
          } else {
            this.isCancelFileReader = false
          }
        },
        immediate: true,
      },
      percent(val) {
        let isDisabled = null
        // 上传进度不为0时，禁止提交
        if (val) {
          isDisabled = true
        } else {
          isDisabled = false
        }
  
        this.$emit('disabledSubmitBtn', isDisabled)
      },
    },
    created() {
      this.headers = this.isBigFile
        ? {
            'Content-Type': 'application/json',
            Authorization: getToken(),
          }
        : {
            Authorization: getToken(),
          }
      this.Base_Url = this.baseApi + '/base/Rest/file/upload'
      const orginfo = getAppOrgId(this, true)
      if (orginfo) {
        this.domain = orginfo.appCode.toLocaleLowerCase()
        if (this.domain === 'config') this.domain = 'platform'
        if (this.domain === 'ctmsmaintain') this.domain = 'ctms'
        if (this.domain === 'capturemaintain') this.domain = 'capture'
      } else {
        this.domain = 'platform'
      }
    },
    destroyed() {
      this.isCancelFileReader = true
      if (this.cancel) this.cancel()
    },
    methods: {
      handleAvatarSuccess(info, file, fileList) {
        this.percent = 0
        this.files = fileList
        if (info.code === 0) {
          this.fileCode = info.data
          this.$emit('change', file)
          this.$emit('fileChange', this.getFileLObj())
        } else {
          this.$message.error(info.msg || `上传失败`)
        }
      },
      remove(file, fileList) {
        this.files = fileList
        this.$emit('removeFile', file)
        this.$emit('fileChange', this.getFileLObj())
      },
      getFileLObj() {
        const arr = []
        this.files.forEach((item) => {
          const a = item.name.split('.')
          const type = a[a.length - 1]
          arr.push({
            fileName: item.name,
            fileSize: item.size,
            fileType: '.' + type,
            fileId: item.response.data,
            filePath: item.response.data,
          })
        })
        return arr
      },
      handleAvatarError() {
        this.percent = 0
        this.$message.error(`上传失败`)
      },
      progress(e) {
        this.percent = Math.ceil(e.percent)
      },
      beforeUpload(file) {
        const arr = file.name.split('.')
        const type = arr[arr.length - 1].toLocaleLowerCase()
        if (type === 'sh' || type === 'exe' || type === 'bat') {
          this.$message({
            message: '禁止上传exe、bat和sh文件!',
            type: 'warning',
          })
          return false
        }
  
        // 文件大小限制
        // 把文件大小转为b
        const limitSizeB = this.size * 1024 * 1024
        if (!this.isBigFile && file.size > limitSizeB) {
          this.$message({
            message: '文件大小不能超过' + this.size + 'Mb',
            type: 'warning',
          })
          return false
        }
  
        // 如果未给定格式，那么可以接收所有格式文件
        if (this.types.length === 0) {
          return true
        } else {
          // 把类型全部转为小写后判断
          let isOk = false
          for (let i = 0; i < this.types.length; i++) {
            if (this.types[i].toLocaleLowerCase() === type) {
              isOk = true
              continue
            }
          }
          if (!isOk) {
            this.$message.error(`不支持的文件格式.${type}，请上传${this.types.join('、')}`)
          }
          return isOk
        }
      },
      async handleAvatarChange(file) {
        this.fileRaw = file.raw
        if (!file) return
        if (!this.isBigFile) return
        if (this.isBigFile && !this.beforeUpload(file)) return
        this.percent = 1
  
        const fileName = file.name
  
        // 获取用户选择的文件
        const fileSize = file.size
  
        const chunkSize = this.chunkSize * 1024 * 1024
  
        // 计算当前选择文件需要的分片数量
        const chunkCount = Math.ceil(fileSize / chunkSize)
  
        // 获取文件md5
        const fileMd5 = await this.getFileMd5ByChunk(file.raw, chunkSize, chunkCount)
  
        // 向后端请求本次分片上传初始化
        const initUploadParams = JSON.stringify({
          fileName,
          fileMd5,
        })
  
        axios({
          url: this.baseApi + '/base/Rest/minio/getUploadId',
          data: initUploadParams,
          headers: this.headers,
          method: 'post',
          cancelToken: new axios.CancelToken((c) => {
            // 获取取消axios请求的函数
            this.cancel = c
          }),
        })
          .then(async (res) => {
            const uploadId = res.data.data
  
            const uploadPathParams = JSON.stringify({
              chunkCount,
              fileName,
              uploadId,
            })
  
            // 获取分片数据
            await this.getUploadPath(
              uploadPathParams,
              {
                fileName,
                fileSize,
                uploadId,
              },
              file.raw,
              chunkSize
            )
          })
          .catch(() => {
            this.percent = 0
            if (this.cancel) return
            this.$message.error(`上传失败`)
          })
      },
      getUploadPath(data, fileDate, file, chunkSize) {
        axios({
          url: this.baseApi + '/base/Rest/minio/getUploadPath',
          data,
          headers: this.headers,
          method: 'post',
          cancelToken: new axios.CancelToken((c) => {
            this.cancel = c
          }),
        })
          .then((res) => {
            const chunkUploadUrls = res.data.data
            const promises = chunkUploadUrls.map((url, i) => {
              // 分片开始位置
              const start = i * chunkSize
              // 分片结束位置
              const end = Math.min(fileDate.fileSize, start + chunkSize)
              // 取文件指定范围内的byte，从而得到分片数据
              const _chunkFile = file.slice(start, end)
  
              // 改变进度
              if (parseInt((100 / chunkUploadUrls.length) * i) >= this.percent) {
                this.percent = parseInt((100 / chunkUploadUrls.length) * i)
              }
  
              return axios.put(url, _chunkFile, {
                cancelToken: new axios.CancelToken((c) => {
                  this.cancel = c
                }),
              })
            })
  
            Promise.all(promises)
              .then(() => {
                this.composeFile(fileDate.fileName, fileDate.uploadId)
              })
              .catch((e) => {
                this.percent = 0
                if (this.cancel) return
                this.$message.error(`上传失败`)
              })
          })
          .catch(() => {
            this.percent = 0
            if (this.cancel) return
            this.$message.error(`上传失败`)
          })
      },
      // 请求后端合并文件
      composeFile(fileName, uploadId) {
        // 注意：bucketName请填写你自己的存储桶名称，如果没有，就先创建一个写在这
        const composeParams = JSON.stringify({
          fileName,
          uploadId,
          domain: this.domain,
        })
        axios({
          url: this.baseApi + '/base/Rest/minio/completeFile',
          data: composeParams,
          headers: this.headers,
          method: 'post',
          cancelToken: new axios.CancelToken((c) => {
            this.cancel = c
          }),
        })
          .then((res) => {
            if (res.data.code === '0') {
              this.percent = 100
              const file = { fileName, fileId: res.data.data, raw: this.fileRaw }
              this.$emit('change', file)
              setTimeout(() => {
                this.percent = 0
              }, 100)
            } else {
              this.$message.error(res.data.msg || `上传失败`)
              this.percent = 0
            }
          })
          .catch(() => {
            this.percent = 0
            if (this.cancel) return
            this.$message.error(`上传失败`)
          })
      },
      getFileMd5ByChunk(file, chunkSize, chunkCount) {
        return new Promise((resolve, reject) => {
          const blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice
          const chunks = Math.ceil(file.size / chunkSize)
          let currentChunk = 0
          const spark = new SparkMD5.ArrayBuffer()
          const fileReader = new FileReader()
          fileReader.onload = function (e) {
            spark.append(e.target.result) // Append array buffer
            currentChunk++
  
            if (currentChunk < chunks) {
              loadNext()
            } else {
              const fileMd5 = spark.end()
              // console.info("computed hash", fileMd5); // Compute hash
              resolve(fileMd5)
            }
          }
  
          fileReader.onerror = function (e) {
            // console.warn('oops, something went wrong.')
            reject(e)
          }
  
          const loadNext = () => {
            if (this.isCancelFileReader) {
              this.percent = 0
              return
            }
            const start = currentChunk * chunkSize
            const end = start + chunkSize >= file.size ? file.size : start + chunkSize
  
            const dividend = chunkCount.length > 2 ? 10 : 100
            this.percent = parseInt(currentChunk / dividend + 1)
  
            fileReader.readAsArrayBuffer(blobSlice.call(file, start, end))
          }
  
          loadNext()
        })
      },
    },
  }
  </script>
  <style lang="scss">
  @import 'yootrial-plugins-dt/src/lib/scss/variables.scss';
  .yoo-upload-file {
    &.theme-box .el-upload.el-upload--text {
      width: 100%;
      margin-top: 12px;
    }
    .el-upload-dragger {
      height: 60px;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      .el-icon-upload {
        margin: 0;
        margin-right: 20px;
        font-size: 50px;
      }
      .progress-box {
        position: absolute;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        span {
          color: #000;
          position: relative;
          z-index: 2;
          font-size: 18px;
        }
        .progress {
          position: absolute;
          left: 0;
          width: 100%;
          height: 100%;
          background: $--color-danger;
          &.full {
            background: $--color-success;
          }
        }
      }
    }
  }
  </style>
  ```

  